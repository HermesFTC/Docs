{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hermes","text":"<p>Hermes offers a revolutionary motion profiling and planning algorithm that builds on RoadRunner from ACME Robotics, FTC Team 8367. </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Path Planning with smooth continuity, such as B\u00e9zier curves,   hermite splines, and more! </li> <li>Motion Profiling paths to ensure the most optimal   trajectory for your robot, using either time or displacement</li> <li>Action Framework for easily scalable robot actions   for asynchronous robot control</li> <li>Advanced Following that uses PID control and    voltage-compensated feedforward to accurately follow   trajectories</li> <li>Unparalleled Customization in path generation,    profiling, and following</li> </ul>"},{"location":"#quickstart","title":"QuickStart","text":"<p>We recommend using the QuickStart, as it has all the necessary dependencies and code to get you started. The QuickStart also contains some example OpModes to help you tune your robot's PID gains, which aren't covered by the automatic tuners.</p>"},{"location":"#adding-to-an-existing-project","title":"Adding To An Existing Project","text":"<p>You will need to add the library as a dependency in your Gradle scripts. In your <code>build.dependencies.gradle</code> file, add the following three lines to the <code>dependencies</code> block:</p> <pre><code>    implementation 'gay.zharel.hermes:core:&lt;latest&gt;&gt;'\n    implementation 'gay.zharel.hermes:actions:&lt;latest&gt;'\n    implementation 'gay.zharel.hermes:ftc:&lt;latest&gt;'\n</code></pre> <p>Where <code>latest</code> is replaced by the latest version as displayed above.</p> <p>Then, sync your project with Gradle files.</p>"},{"location":"#tuning","title":"Tuning","text":"<p>To tune Hermes, simply connect to your robot's WiFi network and go to 192.168.43.1:8080/hermes in your browser!</p> <p>The PID gains are not automatically tuned, so you will need to tune them yourself. The <code>ManualFeedbackTuner</code> OpMode from the QuickStart can be used to tune your robot's PID gains using FTC Dashboard.</p>"},{"location":"#api-documentation","title":"API Documentation","text":"<p>API docs for Hermes can be found here. We recommend checking these docs pages,  as they include many features not directly discussed here.</p>"},{"location":"#questions-feedback","title":"Questions? Feedback?","text":"<p>If you have any questions or feedback about Hermes,  feel free to reach out to us through our Discord server!</p> <p>If you find a bug or have a feature request, please open an issue on our GitHub Issues page; if the issue is related to the QuickStart, please open an issue on the QuickStart Issues page instead.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you would like to contribute to Hermes, please fork the repository and create a pull request. We are open to all contributions, and we will review your pull request as soon as possible.</p> <p>Thank you!</p>"},{"location":"changes-from-rr/","title":"Changes From RoadRunner","text":"<p>Hermes has a few major differences from RoadRunner 1.0.</p>"},{"location":"changes-from-rr/#1-automated-tuning","title":"1. Automated Tuning","text":"<p>Hermes includes an automated tuning system that simplifies the process of tuning your robot's drive parameters. Simply connect to your robot's WiFi network and navigate to the tuning page in your web browser. The tuning page will guide you through the process of tuning your robot's drive parameters.</p>"},{"location":"changes-from-rr/#2-trajectory-creation","title":"2. Trajectory Creation","text":"<p>The <code>Drive</code> interface has a <code>trajectoryBuilder</code> method, allowing you to create trajectories without <code>Action</code>s. The API of the <code>TrajectoryBuilder</code> class is very similar to that of <code>TrajectoryActionBuilder</code>,  but its <code>build</code> method returns a <code>List&lt;Trajectory&gt;</code> instead of an <code>Action</code>. Alternatively, the <code>buildToComposite</code> method returns a <code>CompositeTrajectory</code> object, which may be easier to use.</p> <p>We also offer methods to create and profile paths without a builder,  which is documented here.</p>"},{"location":"changes-from-rr/#3-localizers","title":"3. Localizers","text":"<p>In RoadRunner 1.0, localizers were part of the QuickStart. Hermes includes localizers directly in the library,  reducing the need for teams to copy and maintain localizer code from the QuickStart. This eliminates the need for teams to copy and maintain localizer code from the QuickStart.</p> <p>The API for localizers has also changed slightly, with the <code>PARAMS</code> object being replaced by a fluent API for setting parameters.</p> <p>The library provides several localizer implementations: - Two-wheel odometry - For teams using two tracking wheels - Three-wheel odometry - For teams using three tracking wheels - Drive encoder localization - Using drive motor encoders - Pinpoint localization - For teams using the Pinpoint localization system</p> <p>See the Localizers page for detailed information.</p>"},{"location":"changes-from-rr/#4-trajectory-following","title":"4. Trajectory Following","text":"<p>Hermes introduces a new Follower system that separates trajectory following from trajectory creation. RoadRunner 1.0 combines these concepts within Actions,  while Hermes provides dedicated follower objects for asynchronous trajectory execution.</p> <p>Key improvements: - Asynchronous following: Execute trajectories independently of other code - Multiple follower types: <code>TimeFollower</code> (time-based) and <code>DisplacementFollower</code> (path-based) - Flexible end conditions: Customizable conditions for when following should stop - Better disturbance handling: DisplacementFollower can recover from path deviations</p> <p>See the Followers page for detailed information.</p>"},{"location":"changes-from-rr/#5-action-improvements","title":"5. Action Improvements","text":"<p>Hermes includes multiple improvements to RoadRunner's Action framework. Notably, it includes an <code>ActionRunner</code> object to manage asynchronous action queues, and requirements and interruption features for <code>Action</code>s themselves.</p> <p>The Creating and Using Actions guides explain many of these features.</p>"},{"location":"actions/creating-actions/","title":"Creating Actions","text":"<p>Actions are the basic building blocks of Hermes's non-blocking control flow.  They are composable,  stateful commands that can be executed sequentially or in parallel.</p> <p>There are a few ways to create actions:</p>"},{"location":"actions/creating-actions/#action-interface","title":"Action Interface","text":""},{"location":"actions/creating-actions/#implementing-directly","title":"Implementing Directly","text":"<p>The most basic way is to implement the <code>Action</code> interface.  This is a functional interface with a single abstract method, <code>run(p: TelemetryPacket)</code>,  which is called on every loop.  It should return <code>true</code> if the action is still running,  and <code>false</code> if it has completed.  The <code>p</code> argument can be used to communicate information back to FTC Dashboard.</p> KotlinJava <pre><code>class MyAction : Action {\n    override fun run(p: TelemetryPacket): Boolean {\n        // ... do something\n        return true // or false\n    }\n}\n</code></pre> <pre><code>class MyAction implements Action {\n    @Override\n    public boolean run(@NonNull TelemetryPacket p) {\n        // ... do something\n        return true; // or false\n    }\n}\n</code></pre>"},{"location":"actions/creating-actions/#action-lambdas","title":"Action Lambdas","text":"<p>Note that while it is possible to create an <code>Action</code>  by making an implementation of the interface,  it can be tedious to do this for every possible robot action. Since <code>Action</code> is a functional interface,  it is easy to create objects of it using lambda syntax. This means you can create methods of your robot classes that  return Actions without making an entire class.</p> <p>[!TIP] To learn more about lambdas, read  this guide on lambdas in \"Java\", or this guide on higher order functions and lambdas in \"Kotlin\". Hermes doesn't require any advanced knowledge about them,  but if you're interested in contributing to any NextFTC library, or programming in general, it might be useful to know.</p> KotlinJava <pre><code>class Subsystem {\n    fun myAction(): Action {\n        return Action { \n            //the TelemetryPacket paramemter is named `it` by default in the lambda\n            // ... do something\n            true // or false\n        }\n    }\n}\n</code></pre> <pre><code>class Subsystem {\n    public Action myAction() {\n        return p -&gt; { \n            // here we named the TelemetryPacket parameter `p` \n            // ... do something\n            return true; // or false\n        };\n    }\n}\n</code></pre>"},{"location":"actions/creating-actions/#previewing-actions","title":"Previewing Actions","text":"<p>The <code>Action</code> interface also provides a <code>preview()</code> method  that can be overridden to draw a preview of the action on the FTC Dashboard field overlay. This is useful for visualizing the robot's path or other actions during autonomous. The QuickStart's <code>FollowTrajectoryAction</code> implements it to draw the trajectory!</p> KotlinJava <pre><code>class MyAction : Action {\n    override fun run(p: TelemetryPacket): Boolean {\n        // ... do something\n        return true // or false\n    }\n\n    override fun preview(fieldOverlay: Canvas) {\n        // ... draw on the field overlay\n    }\n}\n\n//or \n\nfun myAction(): Action {\n    return Action {\n        // ... do something \n        true // or false\n    }.withPreview {\n        // ... draw on the field overlay\n    }\n}\n</code></pre> <pre><code>class MyAction implements Action {\n    @Override\n    public boolean run(@NonNull TelemetryPacket p) {\n        // ... do something\n        return true; // or false\n    }\n\n    @Override\n    public void preview(@NonNull Canvas fieldOverlay) {\n        // ... draw on the field overlay\n    }\n}\n\n//or \n\nAction myAction() {\n    return p -&gt; { \n        // ... do something \n        return true; // or false\n    }.withPreview(c -&gt; {\n        // ... draw on the field overlay\n    });\n}\n</code></pre>"},{"location":"actions/creating-actions/#action-requirements","title":"Action Requirements","text":"<p>Actions can also declare requirements.  Requirements are a set of objects that the action needs to function. The <code>ActionRunner</code> will ensure that no two actions with the same requirement can run at the same time. This is useful for preventing two different actions from trying to control  the same motor or servo simultaneously.</p> <p>The type of <code>requirements</code> is <code>Set&lt;Any&gt;</code> to allow any object to be a requirement. This can be a subsystem, a motor object, etc.</p> <p>You can specify requirements by overriding the <code>requirements</code> property in your action,  or by calling the <code>withRequirements</code> function,  which returns a copy of the receiver with its argument (either multiple objects or a set of objects) as the requirements.</p> KotlinJava <pre><code>class MyAction(private val subsystem: Subsystem) : Action {\n    override val requirements: Set&lt;Any&gt; = setOf(subsystem)\n\n    override fun run(p: TelemetryPacket): Boolean {\n        // ... do something with the subsystem\n        return true // or false\n    }\n}\n\n//or\n\nclass MySubsystem {\n    fun myAction(): Action {\n        return Action { \n            // ... do something with the subsystem\n            true // or false\n        }.withRequirements(this)\n    }\n}\n</code></pre> <pre><code>class MyAction implements Action {\n    private final Subsystem subsystem;\n    private final HashSet&lt;Object&gt; reqs;\n    //we define reqs as a field so it is not re-initialized every time\n\n    public MyAction(Subsystem subsystem) {\n        this.subsystem = subsystem;\n        this.reqs = new HashSet&lt;&gt;(Collections.singletonList(subsystem));\n    }\n\n    @Override\n    public Set&lt;Object&gt; getRequirements() {\n        return reqs;\n    }\n\n    @Override\n    public boolean run(@NonNull TelemetryPacket p) {\n        // ... do something with the subsystem\n        return true; // or false\n    }\n}\n\n//or\n\nclass MySubsystem {\n    public Action myAction() {\n        return p -&gt; { \n            // ... do something with the subsystem\n            return true; // or false\n        }.withRequirements(this);\n    }\n}\n</code></pre>"},{"location":"actions/creating-actions/#actionex","title":"ActionEx","text":"<p><code>ActionEx</code>, the expanded Action class,  has two main methods of creating new Action types.</p>"},{"location":"actions/creating-actions/#subclassing-actionex","title":"Subclassing <code>ActionEx</code>","text":"<p>For more complex actions, you can use the <code>ActionEx</code> class.  This class provides <code>init()</code>, <code>loop()</code>, and <code>end()</code> methods  that are called at the beginning, during, and at the end of the action, respectively.</p> <p>The <code>loop</code> method of an <code>ActionEx</code> follows the same logic as <code>Action</code>'s <code>run()</code>: it should return <code>true</code> if the action is still running,  and <code>false</code> if it has completed.  Once it returns <code>false</code>, <code>end</code> is triggerred.</p> KotlinJava <pre><code>class MyActionEx : ActionEx() {\n    override fun init(packet: TelemetryPacket) {\n        // ... called once at the beginning\n    }\n\n    override fun loop(packet: TelemetryPacket): Boolean {\n        // ... called on every loop\n        return true // or false\n    }\n\n    override fun end(packet: TelemetryPacket) {\n        // ... called once at the end\n    }\n}\n</code></pre> <pre><code>class MyActionEx extends ActionEx {\n    @Override\n    public void init(@NonNull TelemetryPacket packet) {\n        // ... called once at the beginning\n    }\n\n    @Override\n    public boolean loop(@NonNull TelemetryPacket packet) {\n        // ... called on every loop\n        return true; // or false\n    }\n\n    @Override\n    public void end(@NonNull TelemetryPacket packet) {\n        // ... called once at the end\n    }\n}\n</code></pre>"},{"location":"actions/creating-actions/#building-with-actionex","title":"Building With <code>ActionEx</code>","text":"<p><code>ActionEx</code> also provides a builder-style interface for creating actions.  This is useful for creating complex actions without having to create a new class.</p> KotlinJava <pre><code>val myAction = ActionEx()\n    .withInit { /* ... called once at the beginning */ }\n    .withLoop { /* ... called on every loop */ true }\n    .withEnd { /* ... called once at the end */ }\n    .withRequirements(/* optional */ )\n</code></pre> <pre><code>Action myAction = new ActionEx()\n    .withInit(p -&gt; { /* ... called once at the beginning */ })\n    .withLoop(p -&gt; { /* ... called on every loop */ return true; })\n    .withEnd(p -&gt; { /* ... called once at the end */ })\n    .withRequirements(/* optional */ );\n</code></pre> <p>An <code>InstantAction</code> is a simple action that executes a given function once and then completes.</p> KotlinJava <pre><code>val myInstantAction = InstantAction { \n    // ... do something \n}\n</code></pre> <pre><code>InstantAction myInstantAction = new InstantAction(() -&gt; {\n    // ... do something\n});\n</code></pre>"},{"location":"actions/creating-actions/#interruptible","title":"Interruptible","text":"<p>The <code>Interruptible</code> interface represents an <code>Action</code> that can be interrupted.  When an interruption occurs, the <code>onInterrupt</code> method is called, and the resulting <code>Action</code> is added to the queue.</p> <p>We recommend defining it with the <code>interruptible</code> function,  which accepts an Action:</p> Kotlin <pre><code>class Subsystem {\n    fun myAction(): Action {\n        return Action { \n            //the TelemetryPacket paramemter is named `it` by default in the lambda\n            // ... do something\n            true // or false\n        }.interruptible(Action {\n            // ... do something (like stop the motors the original action needed)\n            false\n        })\n    }\n}\n</code></pre> <p>===</p> <pre><code>```java\nclass Subsystem {\n    public Action myAction() {\n        return p -&gt; { \n            // ... do something\n            return true; // or false\n        }.interruptible(p -&gt; {\n            // ... do something (like stop the motors the original action needed)\n            return false;\n        });\n    }\n}\n```\n</code></pre> <p>Interruption is currently triggered by two things: 1. If <code>ActionRunner</code> detects a requirements collision     (a newly added action has the same requirement as a previously added action),     it will remove the old action from the queue,      and add its <code>onInterrupt</code> action instead. 2. If one action in a <code>RaceAction</code> ends,     the other actions' <code>onInterrupt</code> actions are added to the queue.</p>"},{"location":"actions/creating-actions/#action-groups","title":"Action Groups","text":"<p><code>Hermes</code> provides several ways to combine actions into groups.</p> <ul> <li><code>SequentialAction</code>: Executes a series of actions one after the other.</li> <li><code>ParallelAction</code>: Executes a group of actions at the same time.     The group completes when all actions have completed.</li> <li><code>RaceAction</code>: Executes a group of actions at the same time.     The group completes when any one of the actions completes.</li> <li><code>SleepAction</code> (not technically a group, but a similar utility):     does nothing and completes after the specified <code>Duration</code>.</li> </ul> <p>You can also use the <code>then()</code>, <code>with()</code>, <code>race()</code>, and <code>delay()</code>  functions to chain actions together in a more readable way.</p> KotlinJava <pre><code>val myAction = MyAction1()\n    .then(MyAction2()) // run MyAction2 after MyAction1\n    .with(MyAction3())  // run MyAction3 at the same time\n    .delay(1.0) //wait 1 second before executing\n</code></pre> <pre><code>Action myAction = new MyAction1()\n    .then(new MyAction2()) // run MyAction2 after MyAction1\n    .with(new MyAction3())  // run MyAction3 at the same time\n    .delay(1.0); //wait 1 second before executing\n</code></pre>"},{"location":"actions/creating-actions/#sleepaction","title":"<code>SleepAction</code>","text":"<p>The constructor for <code>SleepAction</code> actually accepts a <code>Duration</code> object, which allows you to more easily specify durations:</p> KotlinJava <pre><code>val delay500ms = SleepAction(500.milliseconds) //extension function from \"Kotlin\" stdlib\n</code></pre> <pre><code>Action delay500ms = SleepAction(Duration.ofMillis(500));\n</code></pre>"},{"location":"actions/using-actions/","title":"Using Actions","text":""},{"location":"actions/using-actions/#runblocking","title":"<code>runBlocking</code>","text":"<p>The simplest way to execute an action is with <code>runBlocking()</code>.  This function will run the given action to completion while blocking the current thread. This is useful for simple, sequential autonomous op modes.</p> KotlinJava <pre><code>runBlocking(MyAction())\n</code></pre> <pre><code>Actions.runBlocking(new MyAction());\n</code></pre> <p>While the action is running, telemetry packets are sent to FTC Dashboard,  allowing you to visualize the action's state.</p>"},{"location":"actions/using-actions/#actionrunner","title":"<code>ActionRunner</code>","text":"<p>For more complex scenarios, like TeleOp,  where you need to run multiple actions concurrently,  you can use the <code>ActionRunner</code>. It is a singleton object that manages a queue of asynchronous actions.</p>"},{"location":"actions/using-actions/#running-actions","title":"Running Actions","text":"<p>To run an action with the <code>ActionRunner</code>, simply call <code>ActionRunner.run()</code>:</p> KotlinJava <pre><code>ActionRunner.run(MyAction())\n</code></pre> <pre><code>ActionRunner.run(new MyAction());\n</code></pre> <p>You can also run multiple actions at once:</p> KotlinJava <pre><code>ActionRunner.run(\n    MyAction1(),\n    MyAction2()\n)\n</code></pre> <pre><code>ActionRunner.run(\n    new MyAction1(),\n    new MyAction2()\n);\n</code></pre>"},{"location":"actions/using-actions/#updating-the-queue","title":"Updating the Queue","text":"<p>The <code>ActionRunner</code> needs to be updated on every loop of your op mode.  This is done by calling <code>ActionRunner.update()</code> at the end of your <code>loop()</code> method.</p> KotlinJava <pre><code>override fun loop() {\n    // ... your other loop code\n\n    ActionRunner.update()\n}\n</code></pre> <pre><code>@Override\npublic void loop() {\n    // ... your other loop code\n\n    ActionRunner.update();\n}\n</code></pre> <p>The <code>update()</code> method will execute the actions in the queue and send telemetry to FTC Dashboard.</p>"},{"location":"actions/using-actions/#action-interruption","title":"Action Interruption","text":"<p>When a new action is added to the queue,  the <code>ActionRunner</code> will check if any of the currently running actions  share any requirements with the new action. If they do, and the running action is <code>Interruptible</code>, its <code>onInterrupt()</code> method will be called, and it will be removed from the queue. This allows you to create complex, priority-based behaviors.</p>"},{"location":"actions/using-actions/#op-mode-lifecycle","title":"Op Mode Lifecycle","text":"<p>The <code>ActionRunner</code> automatically manages the action queue across different op mode stages.  It ensures that the queue is empty before <code>opModePreInit</code> and clears it after <code>opModePostStop</code>.</p>"},{"location":"concepts/custom-followers/","title":"Custom Followers","text":"<p>While Hermes provides <code>TimeFollower</code> and <code>DisplacementFollower</code> for most use cases,  you can create custom followers by implementing the <code>Follower</code> interface.  This allows you to create specialized following behavior for unique requirements.</p>"},{"location":"concepts/custom-followers/#follower-interface","title":"Follower Interface","text":"<p>The <code>Follower</code> interface defines the contract that all followers must implement:</p> KotlinJava <pre><code>interface Follower {\n    val trajectory: Trajectory&lt;*&gt;\n    val drive: Drive\n    val endConditions: Set&lt;EndCondition&gt;\n\n    val currentTarget: Pose2d\n    val lastCommand: PoseVelocity2dDual&lt;Time&gt;\n    val timer: ElapsedTime\n\n    val isDone: Boolean\n\n    fun follow()\n\n    val points: List&lt;Vector2d&gt; get() = listOf(Vector2d.zero)\n}\n</code></pre> <pre><code>public interface Follower {\n    Trajectory&lt;?&gt; getTrajectory();\n    Drive getDrive();\n    Set&lt;EndCondition&gt; getEndConditions();\n\n    Pose2d getCurrentTarget();\n    PoseVelocity2dDual&lt;Time&gt; getLastCommand();\n    ElapsedTime getTimer();\n\n    boolean isDone();\n\n    void follow();\n\n    default List&lt;Vector2d&gt; getPoints() {\n        return List.of(Vector2d.zero);\n    }\n}\n</code></pre>"},{"location":"concepts/custom-followers/#custom-follower-examples","title":"Custom Follower Examples","text":""},{"location":"concepts/custom-followers/#preview-follower","title":"Preview Follower","text":"<p>A follower that doesn't actually move the robot but logs the planned path:</p> KotlinJava <pre><code>class PreviewFollower(\n    override val trajectory: Trajectory&lt;*&gt;,\n    override val drive: Drive,\n    override val endConditions: Set&lt;EndCondition&gt; = EndCondition.default\n) : Follower {\n    override var currentTarget: Pose2d = trajectory[0.0].value()\n        private set\n    override var lastCommand: PoseVelocity2dDual&lt;Time&gt; = PoseVelocity2dDual.zero()\n        private set\n    override val timer: ElapsedTime = ElapsedTime()\n    override var isDone: Boolean = false\n        private set\n\n    private var started = false\n    private var targetIndex = 0.0\n\n    override fun follow() {\n        if (!started) {\n            timer.reset()\n            started = true\n        }\n\n        // Calculate current target based on time\n        val dt = timer.seconds()\n        val target = if (trajectory is TimeTrajectory) {\n            trajectory[dt]\n        } else {\n            // For displacement trajectories, increment slowly\n            targetIndex = minOf(targetIndex + 0.1, trajectory.length())\n            trajectory[targetIndex]\n        }\n\n        currentTarget = target.value()\n\n        // Don't actually move the robot, just log the path\n        println(\"Would move to: ${currentTarget.position}, heading: ${currentTarget.heading}\")\n\n        // Check end conditions\n        isDone = endConditions.any { it.shouldEnd(this) }\n    }\n\n    override val points: List&lt;Vector2d&gt; = baseFollower.points\n}\n</code></pre> <pre><code>public class PreviewFollower implements Follower {\n    private final Trajectory&lt;?&gt; trajectory;\n    private final Drive drive;\n    private final Set&lt;EndCondition&gt; endConditions;\n\n    private Pose2d currentTarget;\n    private PoseVelocity2dDual&lt;Time&gt; lastCommand = PoseVelocity2dDual.zero();\n    private final ElapsedTime timer = new ElapsedTime();\n    private boolean isDone = false;\n\n    private boolean started = false;\n    private double targetIndex = 0.0;\n\n    public PreviewFollower(Trajectory&lt;?&gt; trajectory, Drive drive, Set&lt;EndCondition&gt; endConditions) {\n        this.trajectory = trajectory;\n        this.drive = drive;\n        this.endConditions = endConditions;\n        this.currentTarget = trajectory.get(0.0).value();\n    }\n\n    public PreviewFollower(Trajectory&lt;?&gt; trajectory, Drive drive) {\n        this(trajectory, drive, EndCondition.getDefault());\n    }\n\n    @Override\n    public void follow() {\n        if (!started) {\n            timer.reset();\n            started = true;\n        }\n\n        // Calculate current target based on time\n        double dt = timer.seconds();\n        Pose2dDual&lt;Time&gt; target;\n\n        if (trajectory instanceof TimeTrajectory) {\n            target = trajectory.get(dt);\n        } else {\n            // For displacement trajectories, increment slowly\n            targetIndex = Math.min(targetIndex + 0.1, trajectory.length());\n            target = trajectory.get(targetIndex);\n        }\n\n        currentTarget = target.value();\n\n        // Don't actually move the robot, just log the path\n        System.out.println(\"Would move to: \" + currentTarget.position + \n                         \", heading: \" + currentTarget.heading);\n\n        // Check end conditions\n        isDone = endConditions.stream().anyMatch(condition -&gt; condition.shouldEnd(this));\n    }\n\n    // Implement remaining interface methods...\n    @Override public Trajectory&lt;?&gt; getTrajectory() { return trajectory; }\n    @Override public Drive getDrive() { return drive; }\n    @Override public Set&lt;EndCondition&gt; getEndConditions() { return endConditions; }\n    @Override public Pose2d getCurrentTarget() { return currentTarget; }\n    @Override public PoseVelocity2dDual&lt;Time&gt; getLastCommand() { return lastCommand; }\n    @Override public ElapsedTime getTimer() { return timer; }\n    @Override public boolean isDone() { return isDone; }\n    @Override public List&lt;Vector2d&gt; getPoints() { return baseFollower.getPoints(); }\n}\n</code></pre>"},{"location":"concepts/custom-followers/#slow-motion-follower","title":"Slow-Motion Follower","text":"<p>A follower that executes trajectories at a reduced speed:</p> KotlinJava <pre><code>class SlowMotionFollower(\n    override val trajectory: Trajectory&lt;*&gt;,\n    override val drive: Drive,\n    private val speedMultiplier: Double = 0.5,\n    override val endConditions: Set&lt;EndCondition&gt; = EndCondition.default\n) : Follower {\n\n    private val baseFollower = TimeFollower(trajectory, drive, emptySet())\n\n    override var currentTarget: Pose2d = trajectory[0.0].value()\n        private set\n    override var lastCommand: PoseVelocity2dDual&lt;Time&gt; = PoseVelocity2dDual.zero()\n        private set\n    override val timer: ElapsedTime = ElapsedTime()\n    override var isDone: Boolean = false\n        private set\n\n    override fun follow() {\n        // Let the base follower do the work\n        baseFollower.follow()\n\n        // Scale down the command\n        val baseCommand = baseFollower.lastCommand\n        lastCommand = PoseVelocity2dDual(\n            baseCommand.position,\n            baseCommand.velocity.times(speedMultiplier),\n            baseCommand.acceleration.times(speedMultiplier * speedMultiplier)\n        )\n\n        // Update our state\n        currentTarget = baseFollower.currentTarget\n        isDone = endConditions.any { it.shouldEnd(this) }\n\n        // Send scaled command to drive\n        drive.setDrivePowersWithFF(lastCommand)\n    }\n\n    override val points: List&lt;Vector2d&gt; = baseFollower.points\n}\n</code></pre> <pre><code>public class SlowMotionFollower implements Follower {\n    private final Trajectory&lt;?&gt; trajectory;\n    private final Drive drive;\n    private final Set&lt;EndCondition&gt; endConditions;\n    private final double speedMultiplier;\n\n    private final TimeFollower baseFollower;\n\n    private Pose2d currentTarget;\n    private PoseVelocity2dDual&lt;Time&gt; lastCommand = PoseVelocity2dDual.zero();\n    private final ElapsedTime timer = new ElapsedTime();\n    private boolean isDone = false;\n\n    public SlowMotionFollower(Trajectory&lt;?&gt; trajectory, Drive drive, \n                             double speedMultiplier, Set&lt;EndCondition&gt; endConditions) {\n        this.trajectory = trajectory;\n        this.drive = drive;\n        this.speedMultiplier = speedMultiplier;\n        this.endConditions = endConditions;\n        this.baseFollower = new TimeFollower(trajectory, drive, Set.of());\n        this.currentTarget = trajectory.get(0.0).value();\n    }\n\n    public SlowMotionFollower(Trajectory&lt;?&gt; trajectory, Drive drive, double speedMultiplier) {\n        this(trajectory, drive, speedMultiplier, EndCondition.getDefault());\n    }\n\n    @Override\n    public void follow() {\n        // Let the base follower do the work\n        baseFollower.follow();\n\n        // Scale down the command\n        PoseVelocity2dDual&lt;Time&gt; baseCommand = baseFollower.getLastCommand();\n        lastCommand = new PoseVelocity2dDual&lt;&gt;(\n            baseCommand.position,\n            baseCommand.velocity.times(speedMultiplier),\n            baseCommand.acceleration.times(speedMultiplier * speedMultiplier)\n        );\n\n        // Update our state\n        currentTarget = baseFollower.getCurrentTarget();\n        isDone = endConditions.stream().anyMatch(condition -&gt; condition.shouldEnd(this));\n\n        // Send scaled command to drive\n        drive.setDrivePowersWithFF(lastCommand);\n    }\n\n    // Implement remaining interface methods...\n    @Override public Trajectory&lt;?&gt; getTrajectory() { return trajectory; }\n    @Override public Drive getDrive() { return drive; }\n    @Override public Set&lt;EndCondition&gt; getEndConditions() { return endConditions; }\n    @Override public Pose2d getCurrentTarget() { return currentTarget; }\n    @Override public PoseVelocity2dDual&lt;Time&gt; getLastCommand() { return lastCommand; }\n    @Override public ElapsedTime getTimer() { return timer; }\n    @Override public boolean isDone() { return isDone; }\n    @Override public List&lt;Vector2d&gt; getPoints() { return baseFollower.getPoints(); }\n}\n</code></pre>"},{"location":"concepts/custom-followers/#logging-follower","title":"Logging Follower","text":"<p>A follower that wraps another follower and adds detailed logging:</p> KotlinJava <pre><code>class LoggingFollower(\n    private val baseFollower: Follower,\n    private val logPrefix: String = \"Follower\"\n) : Follower by baseFollower {\n\n    private var stepCount = 0\n\n    override fun follow() {\n        val startTime = System.nanoTime().nanoseconds\n\n        val prevTarget = currentTarget\n        val prevDone = isDone\n\n        baseFollower.follow()\n\n        val endTime = System.nanoTime().nanoseconds\n        val executionTime = (endTime - startTime).toDouble(DurationUnit.MILLISECONDS) // Convert to milliseconds\n\n        stepCount++\n\n        println(\"$logPrefix Step $stepCount:\")\n        println(\"  Execution time: ${executionTime}\")\n        println(\"  Target: ${currentTarget}\")\n        println(\"  Command: ${lastCommand}\")\n        println(\"  Done: $isDone\")\n\n        if (isDone &amp;&amp; !prevDone) {\n            println(\"$logPrefix: Trajectory following completed!\")\n        }\n    }\n}\n</code></pre> <pre><code>public class LoggingFollower implements Follower {\n    private final Follower baseFollower;\n    private final String logPrefix;\n    private int stepCount = 0;\n\n    public LoggingFollower(Follower baseFollower, String logPrefix) {\n        this.baseFollower = baseFollower;\n        this.logPrefix = logPrefix;\n    }\n\n    public LoggingFollower(Follower baseFollower) {\n        this(baseFollower, \"Follower\");\n    }\n\n    @Override\n    public void follow() {\n        long startTime = System.nanoTime();\n\n        Pose2d prevTarget = getCurrentTarget();\n        boolean prevDone = isDone();\n\n        baseFollower.follow();\n\n        long endTime = System.nanoTime();\n        double executionTime = (endTime - startTime) / 1_000_000.0; // Convert to milliseconds\n\n        stepCount++;\n\n        System.out.println(logPrefix + \" Step \" + stepCount + \":\");\n        System.out.println(\"  Execution time: \" + executionTime + \"ms\");\n        System.out.println(\"  Target: \" + getCurrentTarget());\n        System.out.println(\"  Command: \" + getLastCommand());\n        System.out.println(\"  Done: \" + isDone());\n\n        if (isDone() &amp;&amp; !prevDone) {\n            System.out.println(logPrefix + \": Trajectory following completed!\");\n        }\n    }\n\n    // Delegate all other methods to the base follower\n    @Override public Trajectory&lt;?&gt; getTrajectory() { return baseFollower.getTrajectory(); }\n    @Override public Drive getDrive() { return baseFollower.getDrive(); }\n    @Override public Set&lt;EndCondition&gt; getEndConditions() { return baseFollower.getEndConditions(); }\n    @Override public Pose2d getCurrentTarget() { return baseFollower.getCurrentTarget(); }\n    @Override public PoseVelocity2dDual&lt;Time&gt; getLastCommand() { return baseFollower.getLastCommand(); }\n    @Override public ElapsedTime getTimer() { return baseFollower.getTimer(); }\n    @Override public boolean isDone() { return baseFollower.isDone(); }\n    @Override public List&lt;Vector2d&gt; getPoints() { return baseFollower.getPoints(); }\n}\n</code></pre>"},{"location":"concepts/custom-followers/#understanding-delegation-in-loggingfollower","title":"Understanding Delegation in LoggingFollower","text":"<p>The Kotlin version of <code>LoggingFollower</code> uses interface delegation  (<code>Follower by baseFollower</code>) to automatically implement all interface methods   by forwarding them to the <code>baseFollower</code> object.   This eliminates the boilerplate code required in Java where   you must manually delegate every single interface method.  You can still override specific methods (like <code>follow()</code>)  to customize behavior while keeping automatic delegation for everything else.</p>"},{"location":"concepts/custom-followers/#best-practices","title":"Best Practices","text":"<ol> <li>Respect end conditions: Always check and honor the end conditions</li> <li>Update state consistently: Keep all interface properties up to date</li> <li>Handle edge cases: Consider trajectory start/end and error conditions</li> <li>Provide debugging tools: Include telemetry and visualization support</li> <li>Document behavior: Clearly document what your custom follower does differently</li> <li>Test thoroughly: Custom followers can have subtle bugs that are hard to debug</li> <li>Consider composition: Often better to wrap existing followers than rewrite from scratch</li> </ol> <p>Custom followers provide flexibility to adapt the following behavior to your specific needs,  whether it's for advanced control, logging, or unique trajectory handling. </p>"},{"location":"concepts/end-conditions/","title":"End Conditions","text":"<p>End conditions determine when a follower should stop executing.  The <code>EndCondition</code> interface allows you to define custom logic  for when trajectory following should complete.</p>"},{"location":"concepts/end-conditions/#what-are-end-conditions","title":"What are End Conditions?","text":"<p>End conditions are functions that return <code>true</code> when  a follower should stop following a trajectory.  They provide a flexible way to control when trajectory execution completes,  beyond just reaching the end of the planned path.</p> <p>Every follower accepts a set of end conditions that are checked on each loop iteration.  If any end condition returns <code>true</code>,  the follower will stop and mark itself as done.</p>"},{"location":"concepts/end-conditions/#default-end-conditions","title":"Default End Conditions","text":"<p>By default, followers use <code>EndCondition.default</code>, which includes: - Overtime condition: Stops if the trajectory runs 2 seconds longer than its planned duration - Distance from end: Stops when the robot is within 2 inches of the trajectory's end position</p>"},{"location":"concepts/end-conditions/#custom-end-conditions","title":"Custom End Conditions","text":"<p>You can create custom end conditions by implementing the <code>EndCondition</code> interface:</p> KotlinJava <pre><code>val customEndCondition = EndCondition { follower -&gt;\n    // Custom logic here\n    follower.timer.seconds() &gt; 5.0 || someOtherCondition()\n}\n\nval follower = TimeFollower(trajectory, drive, setOf(customEndCondition))\n</code></pre> <pre><code>EndCondition customEndCondition = follower -&gt; {\n    // Custom logic here\n    return follower.getTimer().seconds() &gt; 5.0 || someOtherCondition();\n};\n\nFollower follower = new TimeFollower(trajectory, drive, Set.of(customEndCondition));\n</code></pre>"},{"location":"concepts/end-conditions/#built-in-end-condition-factory-methods","title":"Built-in End Condition Factory Methods","text":"<p>The <code>EndCondition</code> companion object provides several factory methods for common scenarios:</p>"},{"location":"concepts/end-conditions/#time-based-conditions","title":"Time-based Conditions","text":"KotlinJava <pre><code>// Stop if trajectory runs longer than planned duration + timeout\nEndCondition.overTime(duration: Duration)\nEndCondition.overTime(duration: java.time.Duration) \nEndCondition.overTime(timeoutSeconds: Double)\n\n// Examples:\nval timeoutCondition = EndCondition.overTime(3.0) // 3 second timeout\nval kotlinDurationTimeout = EndCondition.overTime(5.seconds)\n</code></pre> <pre><code>// Stop if trajectory runs longer than planned duration + timeout\nEndCondition.overTime(Duration duration)\nEndCondition.overTime(java.time.Duration duration) \nEndCondition.overTime(double timeoutSeconds)\n\n// Examples:\nEndCondition timeoutCondition = EndCondition.overTime(3.0); // 3 second timeout\nEndCondition javaDurationTimeout = EndCondition.overTime(Duration.ofSeconds(5));\n</code></pre>"},{"location":"concepts/end-conditions/#position-based-conditions","title":"Position-based Conditions","text":"KotlinJava <pre><code>// Stop when robot is within specified distance of trajectory end\nEndCondition.dispFromEnd(distance: Double)\n\n// Example:\nval nearEndCondition = EndCondition.dispFromEnd(1.5) // Within 1.5 inches\n</code></pre> <pre><code>// Stop when robot is within specified distance of trajectory end\nEndCondition.dispFromEnd(double distance)\n\n// Example:\nEndCondition nearEndCondition = EndCondition.dispFromEnd(1.5); // Within 1.5 inches\n</code></pre>"},{"location":"concepts/end-conditions/#velocity-based-conditions","title":"Velocity-based Conditions","text":"KotlinJava <pre><code>// Stop when robot velocity drops below threshold\nEndCondition.robotVel(maxVelocity: Double)\n\n// Example:\nval slowDownCondition = EndCondition.robotVel(2.0) // Below 2 in/s\n</code></pre> <pre><code>// Stop when robot velocity drops below threshold\nEndCondition.robotVel(double maxVelocity)\n\n// Example:\nEndCondition slowDownCondition = EndCondition.robotVel(2.0); // Below 2 in/s\n</code></pre>"},{"location":"concepts/end-conditions/#combining-multiple-conditions","title":"Combining Multiple Conditions","text":"<p>You can combine multiple end conditions to create sophisticated stopping logic:</p> KotlinJava <pre><code>val customEndConditions = setOf(\n    EndCondition.overTime(4.0),        // 4 second timeout\n    EndCondition.dispFromEnd(1.0),     // Within 1 inch of end\n    EndCondition.robotVel(1.5),        // Robot moving slower than 1.5 in/s\n    EndCondition { gamepad1.a }        // Manual stop with A button\n)\n\nval follower = TimeFollower(trajectory, drive, customEndConditions)\n</code></pre> <pre><code>Set&lt;EndCondition&gt; customEndConditions = Set.of(\n    EndCondition.overTime(4.0),        // 4 second timeout\n    EndCondition.dispFromEnd(1.0),     // Within 1 inch of end\n    EndCondition.robotVel(1.5),        // Robot moving slower than 1.5 in/s\n    follower -&gt; gamepad1.a             // Manual stop with A button\n);\n\nFollower follower = new TimeFollower(trajectory, drive, customEndConditions);\n</code></pre>"},{"location":"concepts/end-conditions/#common-use-cases","title":"Common Use Cases","text":""},{"location":"concepts/end-conditions/#emergency-stop","title":"Emergency Stop","text":"<p>Create an end condition for emergency stops  (note that gamepad input is not legal in the autonomous period of FTC matches):</p> KotlinJava <pre><code>val emergencyStop = EndCondition { follower -&gt;\n    gamepad1.back || gamepad2.back // Either controller back button\n}\n</code></pre> <pre><code>EndCondition emergencyStop = follower -&gt; gamepad1.back || gamepad2.back;\n</code></pre>"},{"location":"concepts/end-conditions/#time-limits-for-autonomous","title":"Time Limits for Autonomous","text":"<p>Set strict time limits for autonomous periods:</p> KotlinJava <pre><code>val autonomousTimeLimit = EndCondition { follower -&gt;\n    follower.timer.seconds() &gt; 25.0 // Stop 5 seconds before autonomous ends\n}\n</code></pre> <pre><code>EndCondition autonomousTimeLimit = follower -&gt; \n    follower.getTimer().seconds() &gt; 25.0; // Stop 5 seconds before autonomous ends\n</code></pre>"},{"location":"concepts/end-conditions/#position-tolerance","title":"Position Tolerance","text":"<p>Create custom position tolerances:</p> KotlinJava <pre><code>val tightTolerance = EndCondition { follower -&gt;\n    val target = follower.currentTarget\n    val current = follower.drive.localizer.pose\n    val error = target - current\n    error.position.norm() &lt; 0.5 &amp;&amp; abs(error.heading.log()) &lt; Math.toRadians(2.0)\n}\n</code></pre> <pre><code>EndCondition tightTolerance = follower -&gt; {\n    Pose2d target = follower.getCurrentTarget();\n    Pose2d current = follower.getDrive().getLocalizer().getPose();\n    Pose2d error = target.minus(current);\n    return error.position.norm() &lt; 0.5 &amp;&amp; \n           Math.abs(error.heading.log()) &lt; Math.toRadians(2.0);\n};\n</code></pre>"},{"location":"concepts/end-conditions/#best-practices","title":"Best Practices","text":""},{"location":"concepts/end-conditions/#always-include-a-timeout","title":"Always Include a Timeout","text":"<p>Never rely solely on position or velocity conditions -  always include a timeout to prevent infinite loops:</p> KotlinJava <pre><code>val safeConditions = setOf(\n    EndCondition.dispFromEnd(1.0),     // Primary condition\n    EndCondition.overTime(5.0)         // Safety timeout\n)\n</code></pre> <pre><code>Set&lt;EndCondition&gt; safeConditions = Set.of(\n    EndCondition.dispFromEnd(1.0),     // Primary condition\n    EndCondition.overTime(5.0)         // Safety timeout\n);\n</code></pre>"},{"location":"concepts/end-conditions/#test-end-conditions","title":"Test End Conditions","text":"<p>Test your end conditions thoroughly, especially custom ones:</p> KotlinJava <pre><code>// Test the condition logic separately\nfun testEndCondition() {\n    val condition = EndCondition.robotVel(2.0)\n    // Simulate follower state and verify condition behavior\n}\n</code></pre> <pre><code>// Test the condition logic separately\npublic void testEndCondition() {\n    EndCondition condition = EndCondition.robotVel(2.0);\n    // Simulate follower state and verify condition behavior\n}\n</code></pre>"},{"location":"concepts/end-conditions/#use-appropriate-tolerances","title":"Use Appropriate Tolerances","text":"<p>Choose tolerances that match your robot's capabilities and requirements:</p> <ul> <li>Precise positioning: Use smaller distance tolerances (0.5-1.0 inches)</li> <li>General movement: Use larger distance tolerances (1.0-3.0 inches)  </li> <li>Fast movements: Use velocity-based conditions to detect when movement stops</li> <li>Critical timing: Use strict time limits with appropriate buffers</li> </ul> <p>End conditions are a powerful tool for creating robust and reliable autonomous routines.  By combining different types of conditions,  you can ensure your robot behaves predictably in various scenarios.</p>"},{"location":"concepts/followers/","title":"Followers","text":"<p>Followers are objects that enable your robot to execute trajectories asynchronously.  They provide the bridge between your planned trajectories and your robot's actual movement, continuously calculating and sending control commands to your drive system.</p>"},{"location":"concepts/followers/#what-is-a-follower","title":"What is a Follower?","text":"<p>A <code>Follower</code> is an interface that manages trajectory execution by: - Tracking the current target position along a trajectory - Computing control commands to reach that target - Managing timing and completion status - Handling end conditions for when to stop following</p> <p>All followers implement the core <code>Follower</code> interface, which provides:</p> <ul> <li><code>trajectory: Trajectory&lt;*&gt;</code> - The trajectory to follow</li> <li><code>drive: Drive</code> - The drive system to control</li> <li><code>endConditions: Set&lt;EndCondition&gt;</code> - Conditions that determine when to stop</li> <li><code>currentTarget: Pose2d</code> - The current target position on the trajectory</li> <li><code>isDone: Boolean</code> - Whether the follower has finished execution</li> <li><code>follow()</code> - The main method called each loop to update robot control</li> </ul>"},{"location":"concepts/followers/#types-of-followers","title":"Types of Followers","text":"<p>Hermes provides two main types of followers, each with different approaches to trajectory following:</p>"},{"location":"concepts/followers/#timefollower","title":"TimeFollower","text":"<p><code>TimeFollower</code> uses a time-based approach to trajectory following. It starts an internal timer when following begins and directs the robot to the pose that should be reached at the current elapsed time.</p> <p>How it works: 1. Starts a stopwatch when <code>follow()</code> is first called 2. Uses elapsed time to determine the target pose from the trajectory 3. Directs the feedback controller to minimize the error between current and target poses</p> <p>Best for: - Predictable, smooth motion - When timing is critical - Trajectories where you want consistent velocity profiles</p> <p>Example usage:</p> KotlinJava <pre><code>val trajectory = drive.trajectoryBuilder()\n    .forward(24.0)\n    .splineTo(Vector2d(24.0, 24.0), Math.toRadians(90.0))\n    .buildToComposite()\n\nval follower = TimeFollower(trajectory, drive)\n</code></pre> <pre><code>Trajectory&lt;Arclength&gt; trajectory = drive.trajectoryBuilder()\n    .forward(24.0)\n    .splineTo(new Vector2d(24.0, 24.0), Math.toRadians(90.0))\n    .buildToComposite();\n\nFollower follower = new TimeFollower(trajectory, drive);\n</code></pre>"},{"location":"concepts/followers/#displacementfollower","title":"DisplacementFollower","text":"<p><code>DisplacementFollower</code> uses a displacement-based approach.  Instead of following a time schedule,  it finds the closest point on the trajectory's path to the robot's current position and targets that location.</p> <p>How it works: 1. Continuously calculates the robot's position relative to the trajectory path 2. Finds the closest point on the path to the current robot position 3. Directs the robot to that closest point, naturally progressing along the path</p> <p>Best for: - Robust following that can recover from disturbances - When the robot might get pushed off course - Situations where timing is less important than path accuracy</p> <p>Example usage:</p> KotlinJava <pre><code>val trajectory = drive.trajectoryBuilder()\n    .forward(24.0)\n    .splineTo(Vector2d(24.0, 24.0), Math.toRadians(90.0))\n    .buildToComposite()\n\nval follower = DisplacementFollower(trajectory, drive)\n</code></pre> <pre><code>Trajectory&lt;Arclength&gt; trajectory = drive.trajectoryBuilder()\n    .forward(24.0)\n    .splineTo(new Vector2d(24.0, 24.0), Math.toRadians(90.0))\n    .buildToComposite();\n\nFollower follower = new DisplacementFollower(trajectory, drive);\n</code></pre>"},{"location":"concepts/followers/#choosing-between-timefollower-and-displacementfollower","title":"Choosing Between TimeFollower and DisplacementFollower","text":"<p>TimeFollower</p> <ul> <li>Advantages:<ul> <li>Tested: This follower is based on the widely used RoadRunner 1.0 following algorithm</li> <li>Time consistency: Maintains predictable timing throughout trajectory execution</li> <li>Automatic speed adjustment: Speeds up if behind schedule, slows down if ahead</li> </ul> </li> <li>Disadvantages:<ul> <li>Speed limitations: Cannot run at full speed due to timing constraints</li> <li>Poor disturbance handling: Gets disrupted easily by other robots or obstacles</li> <li>Quick failure: Gives up quickly when paths fail or encounter issues</li> <li>Rigid timing: Slowing down when ahead of schedule can be suboptimal</li> </ul> </li> </ul> <p>DisplacementFollower</p> <ul> <li>Advantages:<ul> <li>Full speed capability: Can run at maximum speed when correctly implemented</li> <li>Robust to disturbances: Handles other robots and obstacles much better</li> <li>Flexible starting: Can deal with starting paths from incorrect positions</li> <li>Better design: Generally more robust and well-designed architecture</li> </ul> </li> <li>Disadvantages:<ul> <li>Less used: Newer implementation with less real-world testing</li> </ul> </li> </ul> <p>Use TimeFollower when:</p> <ul> <li>You need proven, reliable behavior</li> <li>Timing consistency is critical</li> <li>Operating in controlled environments</li> <li>You're new to trajectory following</li> </ul> <p>Use DisplacementFollower when:</p> <ul> <li>Maximum speed is important</li> <li>You expect disturbances (other robots, field elements)</li> <li>You need robust recovery from path deviations</li> <li>You want the most advanced following algorithm</li> </ul> <p>Migration Path:</p> <p>If you're currently using TimeFollower and want better performance,  consider testing DisplacementFollower in a controlled environment first.  The developers of Hermes have found DisplacementFollower superior once properly tuned,  but it has not been as widely tested in the competition environment.</p> <p>Both followers can be used interchangeably in most situations,  so you can experiment to see which works better for your specific robot and use case.</p>"},{"location":"concepts/followers/#follower-parameters","title":"Follower Parameters","text":"<p><code>FollowerParams</code> allows you to configure how followers behave:</p> KotlinJava <pre><code>data class FollowerParams(\n    val profileParams: ProfileParams,     // Motion profile constraints\n    val velConstraint: VelConstraint,     // Velocity limitations\n    val accelConstraint: AccelConstraint  // Acceleration limitations\n)\n</code></pre> <pre><code>public class FollowerParams {\n    public final ProfileParams profileParams;     // Motion profile constraints\n    public final VelConstraint velConstraint;     // Velocity limitations\n    public final AccelConstraint accelConstraint; // Acceleration limitations\n\n    public FollowerParams(ProfileParams profileParams, \n                         VelConstraint velConstraint,\n                         AccelConstraint accelConstraint) {\n        this.profileParams = profileParams;\n        this.velConstraint = velConstraint;\n        this.accelConstraint = accelConstraint;\n    }\n}\n</code></pre> <p>These parameters control: - Motion Profiling: How velocities and accelerations are planned - Velocity Constraints: Maximum speeds in different directions - Acceleration Constraints: Maximum acceleration limits</p>"},{"location":"concepts/followers/#using-followers-in-practice","title":"Using Followers in Practice","text":""},{"location":"concepts/followers/#basic-usage-pattern","title":"Basic Usage Pattern","text":"KotlinJava <pre><code>class MyAutonomous : OpMode() {\n    private lateinit var drive: MecanumDrive\n    private lateinit var follower: Follower\n\n    override fun init() {\n        drive = MecanumDrive(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n\n        val trajectory = drive.trajectoryBuilder()\n            .forward(24.0)\n            .buildToComposite()\n\n        follower = TimeFollower(trajectory, drive)\n    }\n\n    override fun loop() {\n        if (!follower.isDone) {\n            follower.follow()\n        }\n    }\n}\n</code></pre> <pre><code>public class MyAutonomous extends OpMode {\n    private MecanumDrive drive;\n    private Follower follower;\n\n    @Override\n    public void init() {\n        drive = new MecanumDrive(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n\n        Trajectory&lt;Arclength&gt; trajectory = drive.trajectoryBuilder()\n            .forward(24.0)\n            .buildToComposite();\n\n        follower = new TimeFollower(trajectory, drive);\n    }\n\n    @Override\n    public void loop() {\n        if (!follower.isDone()) {\n            follower.follow();\n        }\n    }\n}\n</code></pre>"},{"location":"concepts/followers/#with-custom-end-conditions","title":"With Custom End Conditions","text":"KotlinJava <pre><code>val stopEarly = EndCondition { follower -&gt;\n    gamepad1.a // Stop if A button is pressed\n}\n\nval follower = DisplacementFollower(\n    trajectory, \n    drive, \n    setOf(stopEarly)\n)\n</code></pre> <pre><code>EndCondition stopEarly = follower -&gt; gamepad1.a; // Stop if A button is pressed\n\nFollower follower = new DisplacementFollower(\n    trajectory, \n    drive, \n    Set.of(stopEarly)\n);\n</code></pre>"},{"location":"concepts/followers/#advanced-features","title":"Advanced Features","text":""},{"location":"concepts/followers/#monitoring-progress","title":"Monitoring Progress","text":"KotlinJava <pre><code>// Check current target position\nval target = follower.currentTarget\n\n// Get the last command sent to the drive\nval command = follower.lastCommand\n\n// Check elapsed time\nval elapsedTime = follower.timer.seconds()\n</code></pre> <pre><code>// Check current target position\nPose2d target = follower.getCurrentTarget();\n\n// Get the last command sent to the drive\nPoseVelocity2dDual&lt;Time&gt; command = follower.getLastCommand();\n\n// Check elapsed time\ndouble elapsedTime = follower.getTimer().seconds();\n</code></pre>"},{"location":"concepts/followers/#debugging-and-visualization","title":"Debugging and Visualization","text":"<p>Followers provide access to trajectory points for debugging:</p> KotlinJava <pre><code>val trajectoryPoints = follower.points\n// Use these points for visualization or debugging\n</code></pre> <pre><code>List&lt;Vector2d&gt; trajectoryPoints = follower.getPoints();\n// Use these points for visualization or debugging\n</code></pre> <p>This makes it easy to visualize the planned path and understand what the follower is trying to achieve.</p>"},{"location":"concepts/followers/#end-conditions","title":"End Conditions","text":"<p>End conditions determine when a follower should stop executing.  They provide flexible control over when trajectory following completes.</p> <p>For detailed information about end conditions,  including built-in factory methods and custom implementations,  see the End Conditions page.</p>"},{"location":"concepts/followers/#custom-followers","title":"Custom Followers","text":"<p>For advanced use cases requiring specialized trajectory following behavior,  you can create custom followers by implementing the <code>Follower</code> interface.</p> <p>See the Custom Followers page for detailed examples and implementation guidance.</p>"},{"location":"concepts/localizers/","title":"Localizers","text":"<p>Hermes supports many localization systems! </p> <p>This guide will not attempt to suggest which localizer you use; there are many resources available for that.</p>"},{"location":"concepts/localizers/#what-is-a-localizer","title":"What is a localizer?","text":"<p>A localizer is an object that provides the robot's position, orientation, and velocity in the field.</p> <p>The most basic localizer is the drive localizer, which uses the encoders on your drive motors to determine the robot's position and orientation. However, many robots use additional sensors, such as deadwheel encoders, IMUs, or optical odometry, to improve localization accuracy.</p> <p>The <code>Localizer</code> interface in Hermes provides a common API for all localizers, and has two properties and one method:</p> <ul> <li><code>pose: Pose2d</code> (mutable): the robot's position and orientation in the field</li> <li><code>vel: PoseVelocity2d</code> (read-only): the robot's velocity in the field</li> <li><code>update(): PoseVelocity2d</code>: updates the localizer's pose and returns the robot's velocity</li> </ul> <p>For Java users, the <code>pose</code> property is translated to <code>Pose2d getPose()</code> and <code>void setPose(Pose2d pose)</code> methods, and the <code>vel</code> property is translated to the <code>PoseVelocity2d getVel()</code> method.</p>"},{"location":"concepts/localizers/#built-in-localizers","title":"Built-in Localizers","text":"<p>Hermes automatically detects which localizer your robot is using based on your hardware configuration!</p>"},{"location":"concepts/localizers/#drive-localizers","title":"Drive Localizers","text":"<p>MecanumDriveLocalizer and TankLocalizer use the encoders on your drive motors to determine the robot's position and orientation.</p>"},{"location":"concepts/localizers/#two-deadwheel-localizer","title":"Two-Deadwheel Localizer","text":"<p>TwoDeadWheelLocalizer is for robots with two deadwheel pods (one parallel and one perpendicular to the robot's forward direction). Do not use this if you have the Pinpoint localization system.</p>"},{"location":"concepts/localizers/#three-deadwheel-localizer","title":"Three-Deadwheel Localizer","text":"<p>ThreeDeadWheelLocalizer is for robots with three deadwheel pods (two parallel and one perpendicular to the robot's forward direction).</p>"},{"location":"concepts/localizers/#pinpoint-localizer","title":"Pinpoint Localizer","text":"<p>PinpointLocalizer is for the goBILDA Pinpoint localization system  with two deadwheel pods.</p>"},{"location":"concepts/localizers/#otos-localizer","title":"OTOS Localizer","text":"<p>OTOSLocalizer is for the SparkFun Optical Odometry (OTOS) system.</p>"},{"location":"concepts/localizers/#custom-localizers","title":"Custom Localizers","text":"<p>If you want to create a custom localizer, you can implement the <code>Localizer</code> interface  and provide your own implementation of the properties and method described above:</p> KotlinJava <pre><code>class CustomLocalizer : Localizer {\n    override var pose: Pose2d = Pose2d.zero\n\n    override var vel = PoseVelocity2d.zero\n        private set\n\n    override fun update(): PoseVelocity2d {\n        pose = // calculate new pose\n        vel = // calculate velocity\n        return vel\n    }\n}\n</code></pre> <p>Note that we create both <code>pose</code> and <code>vel</code> as mutable properties, despite being read-only in the interface.  This means that we can update both the <code>pose</code> and <code>vel</code> properties internally in the <code>update</code> method, but only <code>pose</code> can be set externally.</p> <pre><code>public class CustomLocalizer implements Localizer {\n    private Pose2d pose = Pose2d.zero();\n    private PoseVelocity2d vel = PoseVelocity2d.zero();\n\n    @Override\n    public Pose2d getPose() {\n        return pose;\n    }\n\n    @Override\n    public void setPose(Pose2d pose) {\n        this.pose = pose;\n    }\n\n    @Override\n    public PoseVelocity2d getVel() {\n        return vel;\n    }\n\n    @Override\n    public PoseVelocity2d update() {\n        pose = // calculate new pose\n        vel = // calculate velocity\n        return vel;\n    }\n}\n</code></pre>"},{"location":"concepts/traj-generation/","title":"Path and Trajectory Generation","text":"<p>While the <code>TrajectoryBuilder</code> API is great for making continuous and connected paths,  it does not allow as much customization as manually creating the Path and <code>Trajectory</code> objects.</p> <p>Hermes actually has two types of path: <code>PosePath</code> and <code>PositionPath&lt;Param&gt;</code> (the <code>Param</code> type parameter will be explained in a different guide). The main difference is that <code>PositionPath</code>s are only for, well, positions, while <code>PosePath</code>s also include headings.  An example of a <code>PositionPath</code> is a <code>Line</code>,  which simply connects two <code>Vector2d</code>s.</p>"},{"location":"concepts/traj-generation/#types-of-positionpath","title":"Types of <code>PositionPath</code>","text":"<p>The primary types of <code>PositionPath</code> are 1. <code>Line</code>s, which are straight lines that connect <code>Vector2d</code>s, 2. Quintic hermite splines, which are used by <code>splineTo</code> and its variants, and 3. B\u00e9zier curves, which can only be created manually.</p> <p>Creating a <code>Line</code> is easy!  Simply pass the two points you are creating into its constructor:</p> KotlinJava <pre><code>val line = Line(Vector2d(0.0, 0.0), Vector2d(10.0, 10.0))\n</code></pre> <pre><code>PositionPath&lt;Arclength&gt; line = \n    new Line(new Vector2d(0.0, 0.0), new Vector2d(10.0, 10.0));\n</code></pre> <p>Splines and B\u00e9zier curves, however, require a little more work. Both curve types are implemented parametrically,  meaning the x and y curves are separate objects that both depend on a parameter <code>t</code>. In addition, the <code>QuinticSpline1d</code> and <code>BezierCurve1d</code> classes expect <code>t</code> to range solely from 0.0 to 1.0. This means more math (integration, for those who know calculus)  is required to allow <code>t</code> to range through the full length of the curve.</p> <p>The library conveniently provides a function to generate a B\u00e9zier curve  using <code>Vector2d</code>s as control points,  allowing end users to skip the extra steps described above:</p> KotlinJava <pre><code>val curve = fromPoints(\n    Vector2d(0.0, 0.0),\n    Vector2d(10.0, 10.0),\n    Vector2d(10.0, 30.0)\n)\n</code></pre> <p>The <code>fromPoints</code> function comes from the file <code>BezierCurves.kt</code>.</p> <pre><code>PositionPath&lt;Arclength&gt; curve = BezierCurves.fromPoints(\n        new Vector2d(0.0, 0.0),\n        new Vector2d(10.0, 10.0),\n        new Vector2d(10.0, 30.0)\n);\n</code></pre> <p>The official type returned by <code>fromPoints</code> is <code>ArcLengthReparamCurve2d</code>, which is essentially a fancy name for a curve that ranges from 0.0 to its full length.</p> <p>Due to the nature of hermite splines,  it is difficult to create them by themselves. We recommend using the <code>trajectoryBuilder</code> API's <code>splineTo</code> and related methods instead.</p>"},{"location":"concepts/traj-generation/#types-of-posepath","title":"Types of <code>PosePath</code>","text":"<p>Hermes also includes three default functions in the <code>PositionPath</code> interface to add heading paths, which creates <code>PosePath</code> objects!</p> <p>The four major types of heading paths include: 1. Tangent heading, where the heading is based off the tangent of the curve, 2. Constant heading, 3. Linear heading interpolation, and 4. Spline heading interpolation, which actually uses a <code>QuinticSpline1d</code> to smoothly interpolate headings</p> <p>The link to the KDoc provides an explanation on how to add heading paths  to a <code>PositionPath</code> to create a <code>PosePath</code>.</p>"},{"location":"concepts/traj-generation/#turning-a-posepath-into-a-trajectory","title":"Turning A <code>PosePath</code> into a <code>Trajectory</code>","text":"<p>A trajectory is simply a path and a profile!</p> <p>Motion profiling in Hermes is based on your tuning, so the easiest way to create a profile is with the <code>createProfile(path: PosePath)</code>  function of <code>Drive</code>.  It uses your tuned constants and parameters to generate a forward profile of your path, and returns a <code>DisplacementProfile</code> object. To create a <code>TimeProfile</code> object, you can simply pass the displacement-based profile into <code>TimeProfile</code>'s constructor.</p> <p>Similarly, the <code>createTrajectory(path: PosePath)</code> function of <code>Drive</code> uses your tuned constants to create a profile of your path, and then returns a <code>DisplacementTrajectory</code> object based on it.</p>"},{"location":"examples/action-builder/","title":"Action Builder Example","text":"<p>The easiest way to create a Hermes autonomous is with <code>actionBuilder</code>, similarly to RoadRunner 1.0.  Both <code>TankDrive</code> and <code>MecanumDrive</code> have an <code>actionBuilder</code> method, with an optional <code>startPose: Pose2d</code> parameter. If <code>startPose</code> is not provided, it defaults to <code>localizer.pose</code>.</p> <p>All of the <code>TrajectoryActionBuilder</code> functions are documented here.</p> <p>Here is an example of how to use <code>actionBuilder</code>:</p> KotlinJava <pre><code>@Autonomous\n@Disabled\nclass ActionBuilderExampleKt : LinearOpMode() {\n    lateinit var drive: MecanumDrive\n    //because the variable is not initialized upon declaration, we add the lateinit modifier\n    //remember that we can't initialize it until the runOpMode method, as it relies on hardwareMap\n    //which itself is not initialized until then\n    lateinit var action: Action\n\n    override fun runOpMode() {\n        drive = MecanumDriveFactory.build(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n        action = drive.actionBuilder()\n            .forward(10.0)\n            .splineTo(Vector2d(10.0, 10.0), Math.toRadians(90.0))\n            .build()\n\n        waitForStart()\n\n        ActionRunner.runBlocking(action)\n    }\n}\n</code></pre> <pre><code>@Autonomous\n@Disabled\npublic class ActionBuilderExample extends LinearOpMode {\n    MecanumDrive drive;\n    Action action;\n\n    @Override\n    public void runOpMode() throws InterruptedException {\n        drive = MecanumDriveFactory.build(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n        action = drive.actionBuilder() //since startPose is not provided, it will be Pose2d(0.0, 0.0, 0.0)\n                .forward(10.0)\n                .splineTo(new Vector2d(10.0, 10.0), Math.toRadians(90.0))\n                .build();\n\n        waitForStart();\n\n        ActionRunner.runBlocking(action);\n    }\n}\n</code></pre>"},{"location":"examples/custom-actions/","title":"Custom Actions","text":""},{"location":"examples/custom-actions/#basic-examples","title":"Basic Examples","text":"<p>In this guide, you will learn how to create your own custom actions for your subsystems.  We will be creating a simple intake subsystem with a single motor.</p>"},{"location":"examples/custom-actions/#step-1-create-your-subsystem","title":"Step 1: Create your subsystem","text":"<p>First, we need to create our subsystem.  NextRunner does not include any formal Subsystem class or interface, but we can create a class and pass in a <code>HardwareMap</code> instance to the constructor in order to access hardware.</p> KotlinJava <pre><code>class Intake(hwMap: HardwareMap) {\n    private val motor = hwMap[DcMotorEx::class.java, \"intake_motor\"]\n}\n</code></pre> <pre><code>public class Intake {\n    private DcMotorEx motor;\n    public Intake(HardwareMap hwMap) { \n        motor = hwMap.get(DcMotorEx.class, \"intake_motor\");\n    }\n}\n</code></pre>"},{"location":"examples/custom-actions/#step-2-create-your-actions","title":"Step 2: Create your actions","text":"<p>Now, we will create two actions: <code>run()</code> and <code>stop()</code>. The <code>run()</code> action will turn the intake motor on, and the <code>stop()</code> action will turn it off.</p>"},{"location":"examples/custom-actions/#run-action","title":"<code>run()</code> action","text":"<p>To create the <code>run()</code> action, we will create a new <code>Action</code> that sets the motor power to 1.</p> KotlinJava <pre><code>fun run(): Action = Action { \n    motor.power = 1.0\n    true\n}\n</code></pre> <pre><code>public Action run() {\n    return p -&gt; {\n        motor.setPower(1.0);\n        return true;\n    };\n}\n</code></pre> <p>Note that we return <code>true</code> at the end of the action. This is because we want the action to continue running until it is interrupted by another action (like <code>stop()</code>).</p>"},{"location":"examples/custom-actions/#stop-action","title":"<code>stop()</code> action","text":"<p>Now, let's create the <code>stop()</code> action. This action will set the motor power to 0 and then complete.</p> KotlinJava <pre><code>fun stop(): Action = Action { \n    motor.power = 0.0\n    false\n}\n</code></pre> <pre><code>public Action stop() {\n    return p -&gt; {\n        motor.setPower(0.0);\n        return false;\n    };\n}\n</code></pre> <p>This time, we return <code>false</code> at the end of the action. This tells the <code>ActionRunner</code> that the action is complete and can be removed from the queue.</p>"},{"location":"examples/custom-actions/#final-result","title":"Final Result","text":"<p>Here is the final code for our <code>Intake</code> subsystem:</p> KotlinJava <pre><code>class Intake(hwMap: HardwareMap) {\n    private val motor = hwMap[DcMotorEx::class.java, \"intake_motor\"]\n\n    fun run(): Action = Action { \n        motor.power = 1.0\n        true\n    }\n\n    fun stop(): Action = Action { \n        motor.power = 0.0\n        false\n    }\n}\n</code></pre> <pre><code>public class Intake {\n    private DcMotorEx motor;\n    public Intake(HardwareMap hwMap) {\n        motor = hwMap.get(DcMotorEx.class, \"intake_motor\");\n    }\n\n    public Action run() {\n        return p -&gt; {\n            motor.setPower(1.0);\n            return true;\n        };\n    }\n\n    public Action stop() {\n        return p -&gt; {\n            motor.setPower(0.0);\n            return false;\n        };\n    }\n}\n</code></pre>"},{"location":"examples/custom-actions/#more-complex-actions","title":"More Complex Actions","text":"<p>The <code>run()</code> and <code>stop()</code> actions are simple, but what if we want to create more complex actions? Let's take a look at a few examples.</p>"},{"location":"examples/custom-actions/#lift","title":"Lift","text":"<p>Let's create a lift subsystem that can move to a specific position. This is useful for things like moving a lift to a scoring position.</p> <p>First, let's create our subsystem. We will need a motor for the lift.</p> KotlinJava <pre><code>class Lift(hwMap: HardwareMap) {\n    private val motor = hwMap[DcMotorEx::class.java, \"lift_motor\"]\n}\n</code></pre> <pre><code>public class Lift {\n    private DcMotorEx motor;\n    public Lift(HardwareMap hwMap) { \n        motor = hwMap.get(DcMotorEx.class, \"lift_motor\");\n    }\n}\n</code></pre> <p>Now, let's create an action that moves the lift to a specific position. We will use a simple P controller with a gravity feedforward to move the motor to the target position. The feedforward term will help to counteract the force of gravity on the lift.</p> KotlinJava <pre><code>fun goToPosition(targetPosition: Double): Action = Action {\n    val kP = 0.01 // Proportional gain, this should be tuned\n    val kG = 0.1 // Gravity feedforward, this should be tuned\n\n    val error = targetPosition - motor.currentPosition\n    motor.power = (error * kP) + kG\n\n    // continue if error is greater than 10 ticks\n    abs(error) &gt; 10 \n}\n</code></pre> <pre><code>public Action goToPosition(double targetPosition) {\n    return p -&gt; {\n        double kP = 0.01; // Proportional gain, this should be tuned\n        double kG = 0.1; // Gravity feedforward, this should be tuned\n\n        double error = targetPosition - motor.getCurrentPosition();\n        motor.setPower((error * kP) + kG);\n\n        // continue if error is greater than 10 ticks\n        return Math.abs(error) &gt; 10;\n    };\n}\n</code></pre> <p>This action will move the motor to the <code>targetPosition</code> and then complete once it is within 10 ticks of the target.</p>"},{"location":"examples/custom-actions/#claw","title":"Claw","text":"<p>Now, let's create a claw subsystem that can open and close.</p> KotlinJava <pre><code>class Claw(hwMap: HardwareMap) {\n    private val servo = hwMap[Servo::class.java, \"claw_servo\"]\n}\n</code></pre> <pre><code>public class Claw {\n    private Servo servo;\n    public Claw(HardwareMap hwMap) { \n        servo = hwMap.get(Servo.class, \"claw_servo\");\n    }\n}\n</code></pre> <p>Now, let's create the <code>open()</code> and <code>close()</code> actions. These actions will set the servo position and then complete immediately.</p> KotlinJava <pre><code>fun open(): Action = Action {\n    servo.position = 0.1\n    false // complete immediately\n}\n\nfun close(): Action = Action {\n    servo.position = 0.8\n    false // complete immediately\n}\n</code></pre> <pre><code>public Action open() {\n    return p -&gt; {\n        servo.setPosition(0.1);\n        return false; // complete immediately\n    };\n}\n\npublic Action close() {\n    return p -&gt; {\n        servo.setPosition(0.8);\n        return false; // complete immediately\n    };\n}\n</code></pre> <p>This time, we return <code>false</code> at the end of the action. This tells the <code>ActionRunner</code> that the action is complete and can be removed from the queue.</p>"},{"location":"examples/custom-actions/#final-result_1","title":"Final Result","text":"<p>Here is the final code for our <code>Lift</code> and <code>Claw</code> subsystems:</p> KotlinJava <pre><code>class Lift(hwMap: HardwareMap) {\n    private val motor = hwMap[DcMotorEx::class.java, \"lift_motor\"]\n\n    fun goToPosition(targetPosition: Double): Action = Action {\n        val kP = 0.01 // Proportional gain, this should be tuned\n        val kG = 0.1 // Gravity feedforward, this should be tuned\n\n        val error = targetPosition - motor.currentPosition\n        motor.power = (error * kP) + kG\n\n        // continue if error is greater than 10 ticks\n        abs(error) &gt; 10 \n    }\n}\n\nclass Claw(hwMap: HardwareMap) {\n    private val servo = hwMap[Servo::class.java, \"claw_servo\"]\n\n    fun open(): Action = Action {\n        servo.position = 0.1\n        false // complete immediately\n    }\n\n    fun close(): Action = Action {\n        servo.position = 0.8\n        false // complete immediately\n    }\n}\n</code></pre> <pre><code>public class Lift {\n    private DcMotorEx motor;\n\n    public Lift(HardwareMap hwMap) { \n        motor = hwMap.get(DcMotorEx.class, \"lift_motor\");\n    }\n\n    public Action goToPosition(double targetPosition) {\n        return p -&gt; {\n            double kP = 0.01; // Proportional gain, this should be tuned\n            double kG = 0.1; // Gravity feedforward, this should be tuned\n\n            double error = targetPosition - motor.getCurrentPosition();\n            motor.setPower((error * kP) + kG);\n\n            // continue if error is greater than 10 ticks\n            return Math.abs(error) &gt; 10;\n        };\n    }\n}\n\n// in java these should be placed in separate files\n\npublic class Claw {\n    private Servo servo;\n    public Claw(HardwareMap hwMap) { \n        servo = hwMap.get(Servo.class, \"claw_servo\");\n    }\n\n    public Action open() {\n        return p -&gt; {\n            servo.setPosition(0.1);\n            return false; // complete immediately\n        };\n    }\n\n    public Action close() {\n        return p -&gt; {\n            servo.setPosition(0.8);\n            return false; // complete immediately\n        };\n    }\n}\n</code></pre>"},{"location":"examples/custom-actions/#next-steps","title":"Next Steps","text":"<p>Now that you have created your custom actions,  you can learn how to use them in your TeleOp OpMode in the next guide.</p>"},{"location":"examples/follower/","title":"Follower Example","text":"<p>If you are writing more complicated autonomous routines,  you can use a <code>Follower</code> to follow a path asynchronously. This can, for example, be used with a finite state machine.</p> <p>The QuickStart comes with two types of followers: 1. <code>TimeFollower</code>, which essentially starts a stopwatch and directs the feedback controller to close     the gap between the estimated pose and the desired pose at the current time from the trajectory. 2. <code>DisplacementFollower</code>, which finds the closest point on the trajectory's path to your robot,     and directs the feedback controller to close the gap based on that instead.</p> <p>Both types of followers have their benefits,  which will eventually be discussed on a page of this guide.</p> <p>The following (haha) example uses <code>DisplacementFollower</code>,  but it can be switched out for <code>TimeFollower</code> with no other changes to the <code>OpMode</code>.</p> <p>All of the <code>TrajectoryBuilder</code> functions are documented here.</p> KotlinJava <pre><code>@Autonomous\n@Disabled\nclass FollowerExampleKt : OpMode() {\n    private lateinit var drive: MecanumDrive\n    private lateinit var follower: Follower\n\n    override fun init() {\n        drive = MecanumDriveFactory.build(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n        val traj: Trajectory&lt;Arclength&gt; = drive.trajectoryBuilder()\n            .forward(10.0)\n            .splineTo(Vector2d(10.0, 10.0), Math.toRadians(90.0))\n            .buildToComposite()\n\n        follower = DisplacementFollower(traj, drive)\n    }\n\n    override fun loop() {\n        if (!follower.isDone) {\n            follower.follow()\n        }\n    }\n}\n</code></pre> <pre><code>@Autonomous\n@Disabled\npublic class FollowerExample extends OpMode {\n    private MecanumDrive drive;\n    private Follower follower;\n\n    @Override\n    public void init() {\n        drive = MecanumDriveFactory.build(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n        Trajectory&lt;Arclength&gt; traj = drive.trajectoryBuilder()\n                .forward(10.0)\n                .splineTo(new Vector2d(10.0, 10.0), Math.toRadians(90.0))\n                .buildToComposite();\n\n        follower = new DisplacementFollower(traj, drive);\n    }\n\n    @Override\n    public void loop() {\n        if (!follower.isDone()) {\n            follower.follow();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/manual-paths/","title":"Manually Making Paths Example","text":"<p>As discussed earlier, making path and trajectory objects yourself  offers more customization compared to the  <code>trajectoryBuilder</code> API.</p> <p>Caution</p> <p>When creating paths in this way, make sure that the start and end positions and headings line up. Otherwise, the expected starting positions of each trajectory will not match where your robot actually is (unless your robot can teleport), which will confuse the followers.</p> <p>We do not recommend this for new programmers.</p> <p>The following example demonstrates creating <code>PositionPath</code>s, turning them into <code>PosePath</code>s, adding the <code>PosePath</code>s, and finally turning them into a followable <code>Trajectory</code>.</p> KotlinJava <pre><code>@Autonomous\n@Disabled\nclass PathObjectsExampleKt : OpMode() {\n    private lateinit var drive: MecanumDrive\n    private lateinit var follower: Follower\n\n    override fun init() {\n        drive = MecanumDriveFactory.build(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n\n        val path1: PosePath = Line(\n            Vector2d(0.0, 0.0),\n            Vector2d(10.0, 10.0)\n        ).withTangentHeading()\n\n        val path2: PosePath = fromPoints(\n            Vector2d(10.0, 10.0),\n            Vector2d(20.0, 20.0),\n            Vector2d(10.0, 10.0)\n        ).withLinearHeading(Math.PI / 4, 0.0)\n\n        val trajectory = drive.createTrajectory(path1 + path2) \n        //the + operator was overloaded for the PosePath interface,\n        //allowing us to make a CompositePosePath!\n\n        follower = DisplacementFollower(trajectory, drive)\n    }\n\n    // the loop is the same as the TimeFollower example\n    override fun loop() {\n        if (!follower.isDone) {\n            follower.follow()\n        }\n    }\n}\n</code></pre> <pre><code>@Autonomous\n@Disabled\npublic class PathObjectsExample extends OpMode {\n    private MecanumDrive drive;\n    private Follower follower;\n\n    @Override\n    public void init() {\n        drive = MecanumDriveFactory.build(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n\n        PosePath path1 = new Line(\n                new Vector2d(0.0, 0.0),\n                new Vector2d(10.0, 10.0)\n        ).withTangentHeading();\n\n        PosePath path2 = BezierCurves.fromPoints(\n                new Vector2d(10.0, 10.0),\n                new Vector2d(20.0, 20.0),\n                new Vector2d(10.0, 10.0)\n        ).withLinearHeading(Math.PI/4, 0.0);\n\n        DisplacementTrajectory trajectory = drive.createTrajectory(path1.plus(path2));\n        //the plus function for PosePaths returns a CompositePosePath\n\n        follower = new DisplacementFollower(trajectory, drive);\n    }\n\n    //the loop is the same as the TimeFollower example\n    @Override\n    public void loop() {\n        if (!follower.isDone()) {\n            follower.follow();\n        }\n    }\n}\n</code></pre>"},{"location":"examples/teleop-actions/","title":"Using ActionRunner in TeleOp","text":"<p>This guide will show you how to use <code>ActionRunner</code> to run actions in your TeleOp OpMode.  We will be using the <code>Lift</code> and <code>Claw</code> subsystems from the custom actions guide, and a <code>Drive</code> class from the QuickStart.</p>"},{"location":"examples/teleop-actions/#step-1-create-your-opmode","title":"Step 1: Create your OpMode","text":"<p>First, let's create a new TeleOp OpMode.</p> KotlinJava <pre><code>@TeleOp\nclass MyTeleOp : OpMode() {\n    override fun init() {\n        // initialization code\n    }\n\n    override fun loop() {\n        // main loop\n    }\n}\n</code></pre> <pre><code>@TeleOp\npublic class MyTeleOp extends OpMode {\n    @Override\n    public void init() {\n        // initialization code\n    }\n\n    @Override\n    public void loop() {\n        // main loop\n    }\n}\n</code></pre>"},{"location":"examples/teleop-actions/#step-2-initialize-subsystems","title":"Step 2: Initialize subsystems","text":"<p>Now, let's initialize our <code>Lift</code> and <code>Claw</code> subsystems.</p> KotlinJava <pre><code>@TeleOp\nclass MyTeleOp : OpMode() {\n    private lateinit var lift: Lift\n    private lateinit var claw: Claw\n    private lateinit var drive: Drive \n\n    override fun init() {\n        lift = Lift(hardwareMap)\n        claw = Claw(hardwareMap)\n        drive = MecanumDriveFactory.build(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n    }\n\n    override fun loop() {\n        // main loop\n    }\n}\n</code></pre> <pre><code>@TeleOp\npublic class MyTeleOp extends OpMode {\n    private Lift lift;\n    private Claw claw;\n    private Drive drive;\n\n    @Override\n    public void init() {\n        lift = new Lift(hardwareMap);\n        claw = new Claw(hardwareMap);\n        drive = MecanumDriveFactory.build(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n    }\n\n    @Override\n    public void loop() {\n        // main loop\n    }\n}\n</code></pre>"},{"location":"examples/teleop-actions/#step-3-map-controller-buttons-to-actions","title":"Step 3: Map controller buttons to actions","text":"<p>Now, let's map some controller buttons to actions.  We'll use the <code>gamepad1</code> object to get button presses.</p> <p>To prevent an action from being triggered every loop cycle while a button is held down, we can use the <code>aWasPressed()</code>, <code>bWasPressed()</code>, etc. methods. These methods return true only on the first frame the button is pressed.</p> <p><code>ActionRunner</code> is a named object,  meaning there is one instance of it that is accessed globally. Its functions are called like static methods in Java.</p> KotlinJava <pre><code>// in loop()\nif (gamepad1.aWasPressed()) {\n    ActionRunner.run(claw.open())\n}\n\nif (gamepad1.bWasPressed()) {\n    ActionRunner.run(claw.close())\n}\n\nif (gamepad1.xWasPressed()) {\n    ActionRunner.run(lift.goToPosition(1000.0))\n}\n\nif (gamepad1.yWasPressed()) {\n    ActionRunner.run(lift.goToPosition(0.0))\n}\n</code></pre> <pre><code>// in loop()\nif (gamepad1.aWasPressed()) {\n    ActionRunner.run(claw.open());\n}\n\nif (gamepad1.bWasPressed()) {\n    ActionRunner.run(claw.close());\n}\n\nif (gamepad1.xWasPressed()) {\n    ActionRunner.run(lift.goToPosition(1000));\n}\n\nif (gamepad1.yWasPressed()) {\n    ActionRunner.run(lift.goToPosition(0));\n}\n</code></pre>"},{"location":"examples/teleop-actions/#step-4-set-drive-powers-and-update-the-actionrunner","title":"Step 4: Set Drive Powers and Update the ActionRunner","text":"<p>We set the drive powers based on the gamepad's left and right sticks, but we do not run an action for this. Instead, we directly set the drive power using the <code>setDrivePower()</code> method of the <code>Drive</code> class.  One benefit of <code>ActionRunner</code> is that it allows you to run actions in parallel with other code, such as setting drive powers.</p> <p>Finally, we need to call <code>ActionRunner.update()</code> at the end of our <code>loop()</code> function. This will run the actions and keep them updated.</p> KotlinJava <pre><code>// at the end of loop()\n\ndrive.setDrivePower(PoseVelocity2d(\n    Vector2d(\n        gamepad1.left_stick_y,\n        gamepad1.left_stick_x\n    ),\n    gamepad1.right_stick_x,\n))\n\nActionRunner.update()\n</code></pre> <pre><code>// at the end of loop()\n\ndrive.setDrivePower(new PoseVelocity2d(\n    new Vector2d(\n        gamepad1.left_stick_y,\n        gamepad1.left_stick_x\n    ),\n    gamepad1.right_stick_x,\n));\n\nActionRunner.update();\n</code></pre>"},{"location":"examples/teleop-actions/#final-result","title":"Final Result","text":"<p>Here is the final code for our TeleOp OpMode:</p> KotlinJava <pre><code>@TeleOp\nclass MyTeleOp : OpMode() {\n    private lateinit var lift: Lift\n    private lateinit var claw: Claw\n    private lateinit var drive: Drive\n\n    override fun init() {\n        lift = Lift(hardwareMap)\n        claw = Claw(hardwareMap)\n        drive = MecanumDriveFactory.build(hardwareMap, Pose2d(0.0, 0.0, 0.0))\n    }\n\n    override fun loop() {\n        if (gamepad1.aWasPressed()) {\n            ActionRunner.run(claw.open())\n        }\n\n        if (gamepad1.bWasPressed()) {\n            ActionRunner.run(claw.close())\n        }\n\n        if (gamepad1.xWasPressed()) {\n            ActionRunner.run(lift.goToPosition(1000.0))\n        }\n\n        if (gamepad1.yWasPressed()) {\n            ActionRunner.run(lift.goToPosition(0.0))\n        }\n\n        drive.setDrivePower(PoseVelocity2d(\n            Vector2d(\n                gamepad1.left_stick_y,\n                gamepad1.left_stick_x\n            ),\n            gamepad1.right_stick_x,\n        ))\n\n        ActionRunner.update()\n    }\n}\n</code></pre> <pre><code>@TeleOp\npublic class MyTeleOp extends OpMode {\n    private Lift lift;\n    private Claw claw;\n    private Drive drive;\n\n    @Override\n    public void init() {\n        lift = new Lift(hardwareMap);\n        claw = new Claw(hardwareMap);\n        drive = MecanumDriveFactory.build(hardwareMap, new Pose2d(0.0, 0.0, 0.0));\n    }\n\n    @Override\n    public void loop() {\n        if (gamepad1.aWasPressed()) {\n            ActionRunner.run(claw.open());\n        }\n\n        if (gamepad1.bWasPressed()) {\n            ActionRunner.run(claw.close());\n        }\n\n        if (gamepad1.xWasPressed()) {\n            ActionRunner.run(lift.goToPosition(1000));\n        }\n\n        if (gamepad1.yWasPressed()) {\n            ActionRunner.run(lift.goToPosition(0));\n        }\n\n        drive.setDrivePower(new PoseVelocity2d(\n            new Vector2d(\n                gamepad1.left_stick_y,\n                gamepad1.left_stick_x\n            ),\n            gamepad1.right_stick_x,\n        ));\n\n        ActionRunner.update();\n    }\n}\n</code></pre>"}]}